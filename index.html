<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>ğŸ´ Monad Card Game - Web3 Cryptocurrency Card Battle (Ultimate Fixed)</title>
    <script>
      // ğŸš€ ULTIMATE ETHEREUM PROTECTION SYSTEM - Prevents "Cannot redefine property ethereum" errors
      console.log('ğŸ›¡ï¸ [PROTECTION] å¯åŠ¨ç»ˆæethereumå¯¹è±¡ä¿æŠ¤æœºåˆ¶...');
      
      // Clear all storage and service workers for fresh start
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
          for(let registration of registrations) {
            registration.unregister();
          }
        });
      }
      
      try {
        localStorage.clear();
        sessionStorage.clear();
      } catch(e) {}
      
      // ğŸ”¥ CORE PROTECTION SYSTEM
      (function() {
        let protectedEthereum = null;
        let extensionProviders = [];
        
        // Create safe proxy wrapper for ethereum objects
        const createEthereumProxy = (target) => {
          if (!target) return null;
          
          return new Proxy(target, {
            get(obj, prop) {
              const value = obj[prop];
              if (typeof value === 'function') {
                return value.bind(obj);
              }
              return value;
            },
            set(obj, prop, value) {
              console.log('ğŸ›¡ï¸ [PROXY] å®‰å…¨å¤„ç†ethereumå±æ€§è®¾ç½®:', prop);
              try {
                obj[prop] = value;
                return true;
              } catch(e) {
                console.warn('ğŸ›¡ï¸ [PROXY] å±æ€§è®¾ç½®è¢«ä¿æŠ¤:', e.message);
                return true; // Prevent errors
              }
            }
          });
        };
        
        // Override Object.defineProperty to intercept ethereum redefinition attempts
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          if (obj === window && prop === 'ethereum') {
            console.log('ğŸš¨ [PROTECTION] æ‹¦æˆªethereumå±æ€§å®šä¹‰å°è¯•');
            
            // Store the provider safely
            if (descriptor && descriptor.value && !protectedEthereum) {
              protectedEthereum = createEthereumProxy(descriptor.value);
              extensionProviders.push(descriptor.value);
              console.log('âœ… [PROTECTION] å®‰å…¨ä¿å­˜ethereumæä¾›è€…');
            }
            
            // Return success without actually redefining
            return obj;
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // Set up safe ethereum property with getter/setter
        try {
          originalDefineProperty.call(Object, window, 'ethereum', {
            get() {
              // å¦‚æœæœ‰ä¿æŠ¤çš„ethereumå¯¹è±¡ï¼Œè¿”å›å®ƒ
              if (protectedEthereum) {
                return protectedEthereum;
              }
              
              // å¦‚æœæ²¡æœ‰ï¼Œå°è¯•æŸ¥æ‰¾åŸå§‹çš„ethereumå¯¹è±¡
              // æ£€æŸ¥æ‰©å±•æä¾›è€…æ•°ç»„
              if (extensionProviders.length > 0) {
                const latestProvider = extensionProviders[extensionProviders.length - 1];
                if (latestProvider) {
                  protectedEthereum = createEthereumProxy(latestProvider);
                  console.log('ğŸ”„ [PROTECTION] å»¶è¿Ÿåˆ›å»ºethereumä»£ç†å¯¹è±¡');
                  return protectedEthereum;
                }
              }
              
              // æœ€åå°è¯•ç›´æ¥è®¿é—®å¯èƒ½å­˜åœ¨çš„ethereumå¯¹è±¡
              return null;
            },
            set(value) {
              console.log('ğŸ›¡ï¸ [PROTECTION] ethereum setterè°ƒç”¨ï¼Œå®‰å…¨å¤„ç†...', !!value);
              
              if (value) {
                // æ€»æ˜¯æ›´æ–°æ‰©å±•æä¾›è€…æ•°ç»„
                if (!extensionProviders.includes(value)) {
                  extensionProviders.push(value);
                }
                
                // å¦‚æœæ²¡æœ‰ä¿æŠ¤å¯¹è±¡æˆ–è€…è¿™æ˜¯ä¸€ä¸ªæ–°çš„æä¾›è€…ï¼Œåˆ›å»ºä»£ç†
                if (!protectedEthereum || protectedEthereum !== value) {
                  protectedEthereum = createEthereumProxy(value);
                  console.log('âœ… [PROTECTION] ethereumå¯¹è±¡å®‰å…¨è®¾ç½®å®Œæˆï¼Œæä¾›è€…æ•°é‡:', extensionProviders.length);
                }
              }
              
              return true;
            },
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          console.warn('âš ï¸ [PROTECTION] ethereumå±æ€§è®¾ç½®è­¦å‘Š:', e.message);
        }
        
        // Intercept and neutralize redefinition errors
        const originalError = window.Error;
        window.Error = function(...args) {
          const message = args[0];
          if (typeof message === 'string' && 
              (message.includes('Cannot redefine property ethereum') ||
               (message.includes('ethereum') && message.includes('redefine')))) {
            console.log('ğŸ›¡ï¸ [PROTECTION] æˆåŠŸé˜»æ­¢ethereumé‡å®šä¹‰é”™è¯¯');
            // Return a harmless error instead
            return new originalError('Ethereum redefinition safely handled by protection system');
          }
          return new originalError(...args);
        };
        
        // Monitor and collect wallet extensions
        let scanAttempts = 0;
        const maxScans = 30;
        
        const scanForWallets = () => {
          scanAttempts++;
          
          // ä¸»åŠ¨æ‰«ææ‰€æœ‰å¯èƒ½çš„é’±åŒ…æ³¨å…¥
          let foundWallet = false;
          
          // æ£€æŸ¥ç›´æ¥æ³¨å…¥çš„ethereumå¯¹è±¡
          if (window.ethereum) {
            if (!protectedEthereum) {
              protectedEthereum = createEthereumProxy(window.ethereum);
              if (!extensionProviders.includes(window.ethereum)) {
                extensionProviders.push(window.ethereum);
              }
              foundWallet = true;
              console.log('âœ… [PROTECTION] æ£€æµ‹åˆ°ä¸»ethereumå¯¹è±¡å¹¶å·²ä¿æŠ¤');
            }
          }
          
          // æ£€æŸ¥å…¶ä»–å¸¸è§çš„é’±åŒ…æ³¨å…¥ç‚¹
          ['ethereum', 'web3', 'tronWeb'].forEach(key => {
            if (window[key] && key !== 'ethereum') {
              console.log(`ğŸ” [PROTECTION] æ£€æµ‹åˆ° ${key} é’±åŒ…å¯¹è±¡`);
            }
          });
          
          // ç‰¹åˆ«å¤„ç†MetaMaskå’Œå…¶ä»–é’±åŒ…
          if (window.ethereum?.isMetaMask) {
            console.log('ğŸ¦Š [PROTECTION] MetaMaskå·²æ£€æµ‹å¹¶ä¿æŠ¤');
            foundWallet = true;
          }
          
          if (window.ethereum?.isNightly) {
            console.log('ğŸŒ™ [PROTECTION] Nightlyé’±åŒ…å·²æ£€æµ‹');
            foundWallet = true;
          }
          
          if (foundWallet && scanAttempts > 5) {
            console.log(`ğŸ¯ [PROTECTION] é’±åŒ…æ‰«æå®Œæˆï¼Œæ‰¾åˆ° ${extensionProviders.length} ä¸ªæä¾›è€…`);
            return; // æå‰ç»“æŸæ‰«æ
          }
          
          // Continue scanning for a reasonable time
          if (scanAttempts < maxScans) {
            setTimeout(scanForWallets, 100); // å¢åŠ é—´éš”ä»¥ç»™æ‰©å±•æ›´å¤šæ—¶é—´
          } else {
            console.log('âš ï¸ [PROTECTION] é’±åŒ…æ‰«æè¶…æ—¶ï¼Œå¦‚æœå·²å®‰è£…é’±åŒ…è¯·åˆ·æ–°é¡µé¢');
          }
        };
        
        // Start wallet detection
        scanForWallets();
        
        console.log('ğŸ¯ [PROTECTION] ç»ˆæethereumä¿æŠ¤ç³»ç»Ÿå·²å®Œæˆéƒ¨ç½²ï¼');
      })();
      
      // Final checks on DOM ready and load
      document.addEventListener('DOMContentLoaded', function() {
        console.log('ğŸ”§ [INIT] DOMå°±ç»ªï¼ŒethereumçŠ¶æ€:', !!window.ethereum);
      });
      
      window.addEventListener('load', function() {
        console.log('ğŸ [INIT] é¡µé¢å®Œå…¨åŠ è½½ï¼Œæœ€ç»ˆæ£€æŸ¥å®Œæˆ');
      });
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
