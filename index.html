<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>🎴 Monad Card Game - Web3 Cryptocurrency Card Battle (Ultimate Fixed)</title>
    <script>
      // 🚀 ULTIMATE ETHEREUM PROTECTION SYSTEM - Prevents "Cannot redefine property ethereum" errors
      console.log('🛡️ [PROTECTION] 启动终极ethereum对象保护机制...');
      
      // Clear all storage and service workers for fresh start
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
          for(let registration of registrations) {
            registration.unregister();
          }
        });
      }
      
      try {
        localStorage.clear();
        sessionStorage.clear();
      } catch(e) {}
      
      // 🔥 CORE PROTECTION SYSTEM
      (function() {
        let protectedEthereum = null;
        let extensionProviders = [];
        
        // Create safe proxy wrapper for ethereum objects
        const createEthereumProxy = (target) => {
          if (!target) return null;
          
          return new Proxy(target, {
            get(obj, prop) {
              const value = obj[prop];
              if (typeof value === 'function') {
                return value.bind(obj);
              }
              return value;
            },
            set(obj, prop, value) {
              console.log('🛡️ [PROXY] 安全处理ethereum属性设置:', prop);
              try {
                obj[prop] = value;
                return true;
              } catch(e) {
                console.warn('🛡️ [PROXY] 属性设置被保护:', e.message);
                return true; // Prevent errors
              }
            }
          });
        };
        
        // Override Object.defineProperty to intercept ethereum redefinition attempts
        const originalDefineProperty = Object.defineProperty;
        Object.defineProperty = function(obj, prop, descriptor) {
          if (obj === window && prop === 'ethereum') {
            console.log('🚨 [PROTECTION] 拦截ethereum属性定义尝试');
            
            // Store the provider safely
            if (descriptor && descriptor.value && !protectedEthereum) {
              protectedEthereum = createEthereumProxy(descriptor.value);
              extensionProviders.push(descriptor.value);
              console.log('✅ [PROTECTION] 安全保存ethereum提供者');
            }
            
            // Return success without actually redefining
            return obj;
          }
          return originalDefineProperty.call(this, obj, prop, descriptor);
        };
        
        // Set up safe ethereum property with getter/setter
        try {
          originalDefineProperty.call(Object, window, 'ethereum', {
            get() {
              // 如果有保护的ethereum对象，返回它
              if (protectedEthereum) {
                return protectedEthereum;
              }
              
              // 如果没有，尝试查找原始的ethereum对象
              // 检查扩展提供者数组
              if (extensionProviders.length > 0) {
                const latestProvider = extensionProviders[extensionProviders.length - 1];
                if (latestProvider) {
                  protectedEthereum = createEthereumProxy(latestProvider);
                  console.log('🔄 [PROTECTION] 延迟创建ethereum代理对象');
                  return protectedEthereum;
                }
              }
              
              // 最后尝试直接访问可能存在的ethereum对象
              return null;
            },
            set(value) {
              console.log('🛡️ [PROTECTION] ethereum setter调用，安全处理...', !!value);
              
              if (value) {
                // 总是更新扩展提供者数组
                if (!extensionProviders.includes(value)) {
                  extensionProviders.push(value);
                }
                
                // 如果没有保护对象或者这是一个新的提供者，创建代理
                if (!protectedEthereum || protectedEthereum !== value) {
                  protectedEthereum = createEthereumProxy(value);
                  console.log('✅ [PROTECTION] ethereum对象安全设置完成，提供者数量:', extensionProviders.length);
                }
              }
              
              return true;
            },
            configurable: true,
            enumerable: true
          });
        } catch(e) {
          console.warn('⚠️ [PROTECTION] ethereum属性设置警告:', e.message);
        }
        
        // Intercept and neutralize redefinition errors
        const originalError = window.Error;
        window.Error = function(...args) {
          const message = args[0];
          if (typeof message === 'string' && 
              (message.includes('Cannot redefine property ethereum') ||
               (message.includes('ethereum') && message.includes('redefine')))) {
            console.log('🛡️ [PROTECTION] 成功阻止ethereum重定义错误');
            // Return a harmless error instead
            return new originalError('Ethereum redefinition safely handled by protection system');
          }
          return new originalError(...args);
        };
        
        // Monitor and collect wallet extensions
        let scanAttempts = 0;
        const maxScans = 30;
        
        const scanForWallets = () => {
          scanAttempts++;
          
          // 主动扫描所有可能的钱包注入
          let foundWallet = false;
          
          // 检查直接注入的ethereum对象
          if (window.ethereum) {
            if (!protectedEthereum) {
              protectedEthereum = createEthereumProxy(window.ethereum);
              if (!extensionProviders.includes(window.ethereum)) {
                extensionProviders.push(window.ethereum);
              }
              foundWallet = true;
              console.log('✅ [PROTECTION] 检测到主ethereum对象并已保护');
            }
          }
          
          // 检查其他常见的钱包注入点
          ['ethereum', 'web3', 'tronWeb'].forEach(key => {
            if (window[key] && key !== 'ethereum') {
              console.log(`🔍 [PROTECTION] 检测到 ${key} 钱包对象`);
            }
          });
          
          // 特别处理MetaMask和其他钱包
          if (window.ethereum?.isMetaMask) {
            console.log('🦊 [PROTECTION] MetaMask已检测并保护');
            foundWallet = true;
          }
          
          if (window.ethereum?.isNightly) {
            console.log('🌙 [PROTECTION] Nightly钱包已检测');
            foundWallet = true;
          }
          
          if (foundWallet && scanAttempts > 5) {
            console.log(`🎯 [PROTECTION] 钱包扫描完成，找到 ${extensionProviders.length} 个提供者`);
            return; // 提前结束扫描
          }
          
          // Continue scanning for a reasonable time
          if (scanAttempts < maxScans) {
            setTimeout(scanForWallets, 100); // 增加间隔以给扩展更多时间
          } else {
            console.log('⚠️ [PROTECTION] 钱包扫描超时，如果已安装钱包请刷新页面');
          }
        };
        
        // Start wallet detection
        scanForWallets();
        
        console.log('🎯 [PROTECTION] 终极ethereum保护系统已完成部署！');
      })();
      
      // Final checks on DOM ready and load
      document.addEventListener('DOMContentLoaded', function() {
        console.log('🔧 [INIT] DOM就绪，ethereum状态:', !!window.ethereum);
      });
      
      window.addEventListener('load', function() {
        console.log('🏁 [INIT] 页面完全加载，最终检查完成');
      });
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
